{"title":"Angularで動的にHTMLタグをコンポーネントに埋め込む","date":"2019-11-14","category":"Angular","tag":["html","embed"],"body":"\n\nAngularでは、データバインドを利用したテキストの埋め込み時にセキュリティ上の考慮がなされています。具体的には、scriptやhtmlは自動的にエスケープ処理され、原則的にはhtmlタグを埋め込めないようになっています。\n\nAngularで、markdownから生成したhtmlをタグとして画面に挿入する方法を調査しました。\n\n## 注意点\n\n開発者は、**有害なhtmlデータ**がこれらの処理を通してユーザに送信されないよう、十分に考慮する必要があります。\n\n## SafeHtml型のhtmlデータを[innerHTML]にバインドする\n\n実装例を以下に示します。\n\n**MarkdownService**\n\n```ts\nexport class MarkdownService {\n  constructor(\n    private http: HttpClient,\n    private sanitizer: DomSanitizer,\n    @Inject(\"BASE_URL\") private baseUrl: string,\n  ) {}\n\n  getDocument(path: string): Observable<DocumentInfo> {\n    let docInfo: DocumentInfo;\n    const processor = unified()\n      .use(markdown, { commonmark: true })\n      .use(remarkAttr)\n      .use(remarkRehype, { allowDangerousHTML: true })\n      .use(raw)\n      .use(slug)\n      .use(autoLinkHeadings)\n      .use(highlight)\n      .use(html);\n\n    return this.http.get<DocumentInfo>(this.baseUrl + path).pipe(\n      map(result => {\n\t\t// this.baseUrl + pathにアクセスすると、docInfo型のデータがjsonで取得できる。それをそのまま代入。\n        docInfo = result;\n\n        // set default toc\n        if (!docInfo.toc) {\n          docInfo.toc = \"h2,h3\";\n        }\n\n\t\t// docInfo.bodyはmarkdown形式のデータ。processor.processSync処理でhtmlに変換される\n\t\tdocInfo.bodyHtml = processor.processSync(docInfo.body).contents;\n\n\t\t// bypassSecurityTrustHtmlはhtmlデータをSafeHTMLという特別な型に変換する\n        docInfo.safeBody = this.sanitizer.bypassSecurityTrustHtml(docInfo.bodyHtml);\n        return docInfo;\n      }),\n    );\n  }\n  ...\n}\n```\n\n**document.component.html(抜粋)**\n\n```html\n<div fxFlex class=\"doc-body\" [innerHTML]=\"docInfo?.bodyHtml\" appRouteTransformer>\n```\n\nまたは\n\n```html\n<div fxFlex class=\"doc-body\" [innerHTML]=\"docInfo?.safeBody\" appRouteTransformer>\n```\n\n通常のhtmlデータ(docInfo.bodyHtml)をinnerHTMLにバインドした場合、idやスタイルなどの属性は自動的に取り除かれてしまいます。またブラウザのコンソール上に**安全でないhtmlデータがバインドされた**という警告が表示されます。\n\nDomSanitizer.bypassSecurityTrustHtmlを利用すると、htmlデータはSafeHTML型に変換され、Angularはこのデータを無害なhtmlデータとして取り扱います。つまりすべてそのままの状態でバインドされます。\n\n## ElementRef.nativeElementにバインドする\n\n実装例を以下に示します。\n\n**document.component.html(抜粋)**\n\n```html\n<div fxLayout=\"column\" class=\"doc-container\" [@openClose]=\"isOpen ? 'open' : 'closed'\">\n  <!-- <p *ngIf=\"!docInfo\">loading...</p> -->\n  <ng-container *ngIf=\"docInfo && docInfo?.toc === 'none'\">\n    ...\n  </ng-container>\n  <ng-container *ngIf=\"docInfo && docInfo?.toc !== 'none'\">\n    <div fxLayout=\"row\">\n      <div fxFlex=\"1 1 85%\" fxFlex.lt-md=\"1 1 100%\">\n        <div fxLayout=\"column\">\n          ...\n          <!-- <div fxFlex class=\"doc-body\" [innerHTML]=\"docInfo?.safeBody\" appRouteTransformer></div> -->\n          <div #mdContent fxFlex class=\"doc-body\" appRouteTransformer></div>\n        </div>\n      </div>\n      <div fxFlex=\"1 1 15%\" fxHide.lt-md>\n        <app-document-toc [tocList]=\"tocList\" appRouteTransformer></app-document-toc>\n      </div>\n    </div>\n  </ng-container>\n</div>\n```\n\n**document.component.ts**\n\n```ts\nimport {\n  AfterViewInit,\n  ChangeDetectorRef,\n  Component,\n  ElementRef,\n  OnDestroy,\n  OnInit,\n  ViewChild,\n} from '@angular/core';\n\n@Component({\n  selector: \"app-document\",\n  templateUrl: \"./document.component.html\",\n  styleUrls: [\"./document.component.scss\", \"./vs2015.css\"],\n  animations: [defaultRouteAnimation],\n})\nexport class DocumentComponent implements OnInit, OnDestroy, AfterViewInit {\n  docInfo: DocumentInfo | null;\n  isOpen: boolean = true;\n  tocList: TocItem[] | null;\n\n  // template html中の<div #mdContent>を参照するオブジェクトを定義\n  @ViewChild(\"mdContent\")\n  mdRef: ElementRef<HTMLElement>;\n\n  private fragment: string;\n  private previousPath: string;\n  private onDestroy = new Subject();\n  private routeChangeSubject = new Subject();\n\n  constructor(\n    private markdownService: MarkdownService,\n    private location: Location,\n    private route: ActivatedRoute,\n    private loadingBarService: LoadingBarService,\n    private changeDetector: ChangeDetectorRef,\n  ) {}\n\n  ngOnInit() {\n    ...\n    this.route.url.pipe(takeUntil(this.onDestroy)).subscribe(params => {\n      const docRef = params.map(x => x.path).join(\"/\");\n      if (docRef !== this.previousPath) {\n        this.docInfo = null;\n        this.isOpen = false;\n        this.getMarkdownDocInfo(docRef);\n      } else {\n        this.loadingBarService.hide();\n      }\n      this.previousPath = docRef;\n    });\n  }\n  ...\n  private getMarkdownDocInfo(docRef: string) {\n    const path = this.location.normalize(\"assets/json/\" + docRef + \".json\");\n\n    this.markdownService\n      .getDocument(path)\n      .pipe(takeUntil(this.onDestroy))\n      .subscribe(\n        doc => {\n\t\t  this.docInfo = doc;\n\n\t\t  // 初期画面は<ng-container *ngIf=\"docInfo>の条件設定により\n\t\t  // #mdContentを持つelementがまだ画面にない。\n\t\t  //\n\t\t  // this.docInfoをセットした後に、ChangeDetectorRef.detectChanges()することで\n\t\t  // 仮想DOMの内容が更新され、<ng-container *ngIf=\"docInfo>内のelementに\n\t\t  // アクセスすることができるようになる。\n\t\t  this.changeDetector.detectChanges();\n\n\t\t  // mdRef(#mdContentを持つdiv)のnativeElementにアクセスすることで\n\t\t  // JQueryやjavascriptで過去に行っていたような、htmlタグの操作が可能になる。\n          this.mdRef.nativeElement.innerHTML = doc.bodyHtml;\n        },\n        err => console.error(\"MarkdownService\", err),\n      );\n  }\n  ...\n}\n```\n\n`nativeElement`に対する処理はjavascriptで直接実施されるので、safeHTML型にする必要はなく、サニタイズを考慮せずにhtmlをそのままバインドできます（出来てしまいます）。\n\n## 関連項目\n\n-   [セキュリティ - angular.jp](https://angular.jp/guide/security#bypass-security-apis)\n-   [ElementRef - angular.jp](https://angular.jp/api/core/ElementRef)\n-   [\\[Angular\\]変数のバインドで、htmlタグを埋め込む](https://akamist.com/blog/archives/2223)\n-   [AngularでビューにHTML文書を「バインド」するには？（Property Binding）](https://www.atmarkit.co.jp/ait/articles/1702/13/news127.html)\n"}
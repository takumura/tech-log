{"title":"Angularでgistを表示する","date":"2019-11-14","category":"Angular","tag":["gist","embed","PostScribe"],"body":"\n\n[Angularで動的にHTMLタグをコンポーネントに埋め込む](docs/angular/angular-embed-html-tag){.internal-link}により、htmlを埋め込むことができたが、その中にscriptタグが含まれていた場合、表示させただけではscriptが実行されません。JQueryでいうところの`$()`に相当する、画面描画後にscriptを実行する処理が必要になります。\n\n本tech-log内で、gistのembedを表示するのに本課題を対応する必要があり、解決方法を調査しました。\n\n## PostScribeを利用する\n\n非同期にscriptを実行し、結果をDOMに書き込む[PostScribe](https://krux.github.io/postscribe/)というライブラリを利用することで、gistのembedを実現しました。\n\n**Markdownファイル(抜粋)**\n\n```html\ngistの表示デモ。class=\"gist\"のdivでgistのembedスクリプトを囲います\n<div class=\"gist\">\n\t<script src=\"https://gist.github.com/takumura/bbff68078afb2d0846773965d1678c7c.js\"></script>\n</div>\n```\n\n**document.component.ts（抜粋）**\n\n```ts\nimport {\n  AfterViewInit,\n  ChangeDetectorRef,\n  Component,\n  ElementRef,\n  OnDestroy,\n  OnInit,\n  ViewChild,\n} from '@angular/core';\nimport postscribe from 'postscribe';\n\n@Component({\n  selector: \"app-document\",\n  templateUrl: \"./document.component.html\",\n  styleUrls: [\"./document.component.scss\", \"./vs2015.css\"],\n  animations: [defaultRouteAnimation],\n})\nexport class DocumentComponent implements OnInit, OnDestroy, AfterViewInit {\n  docInfo: DocumentInfo | null;\n  isOpen: boolean = true;\n  tocList: TocItem[] | null;\n\n  // template html中の<div #mdContent>を参照するオブジェクトを定義\n  @ViewChild(\"mdContent\")\n  mdRef: ElementRef<HTMLElement>;\n\n  private fragment: string;\n  private previousPath: string;\n  private onDestroy = new Subject();\n  private routeChangeSubject = new Subject();\n\n  constructor(\n    private markdownService: MarkdownService,\n    private location: Location,\n    private route: ActivatedRoute,\n    private loadingBarService: LoadingBarService,\n    private changeDetector: ChangeDetectorRef,\n  ) {}\n\n  ngOnInit() {\n    ...\n    this.route.url.pipe(takeUntil(this.onDestroy)).subscribe(params => {\n      const docRef = params.map(x => x.path).join(\"/\");\n      if (docRef !== this.previousPath) {\n        this.docInfo = null;\n        this.isOpen = false;\n        this.getMarkdownDocInfo(docRef);\n      } else {\n        this.loadingBarService.hide();\n      }\n      this.previousPath = docRef;\n    });\n  }\n  ...\n  private getMarkdownDocInfo(docRef: string) {\n    const path = this.location.normalize('assets/json/' + docRef + '.json');\n\n    this.markdownService\n      .getDocument(path)\n      .pipe(takeUntil(this.onDestroy))\n      .subscribe(\n        doc => {\n          this.docInfo = doc;\n\n          // detect change to update virtual DOM\n          // and allow to access mdContentRef\n          this.cdRef.detectChanges();\n          this.mdContentRef.nativeElement.innerHTML = this.docInfo.bodyHtml;\n\n          this.showGist();\n          this.generateToc();\n          this.routeChangeSubject.next();\n        },\n        err => console.error('MarkdownService', err),\n      );\n  }\n\n  private showGist() {\n    const gists = this.mdContentRef.nativeElement.querySelectorAll('div.gist');\n    gists.forEach(gist => {\n      postscribe(gist, gist.innerHTML);\n    });\n  }\n  ...\n}\n```\n\n`this.mdContentRef.nativeElement.innerHTML = this.docInfo.bodyHtml;`でhtmlをDOMに反映させた後で、`showGist()`関数を呼んでいます。\n\n`showGist`関数では、`this.mdContentRef.nativeElement.querySelectorAll('div.gist')`で`gist`クラスを持つ`div`タグをリストアップし、発見したすべての`div`に対して`div.innerHTML`、すなわちembedのscriptを実行しています。\n\n```ts\npostscribe(\n  gist,           // div.gistのtag。このdivの中にscript実行結果が書き込まれる。\n  gist.innerHTML  // div.innerHTML = gistのembed script\n);\n```\n\n## 関連項目\n\n-   [postscribe - Github](https://github.com/krux/postscribe)\n-   [VSCode: Settings Syncで環境設定を共有する](docs/env/vscode-settings-sync){.internal-link}\n"}
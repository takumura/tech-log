[{"docRef":"/angular/angular-embed-html-tag","content":{"title":"Angularで動的にHTMLタグをコンポーネントに埋め込む","date":"2019-11-14","category":"Angular","tag":["html","embed"],"body":"\r\n\r\nAngularでは、データバインドを利用したテキストの埋め込み時にセキュリティ上の考慮がなされています。具体的には、scriptやhtmlは自動的にエスケープ処理され、原則的にはhtmlタグを埋め込めないようになっています。\r\n\r\nAngularで、markdownから生成したhtmlをタグとして画面に挿入する方法を調査しました。\r\n\r\n## 注意点\r\n\r\n開発者は、**有害なhtmlデータ**がこれらの処理を通してユーザに送信されないよう、十分に考慮する必要があります。\r\n\r\n## SafeHtml型のhtmlデータを[innerHTML]にバインドする\r\n\r\n実装例を以下に示します。\r\n\r\n**MarkdownService**\r\n\r\n```ts\r\nexport class MarkdownService {\r\n  constructor(\r\n    private http: HttpClient,\r\n    private sanitizer: DomSanitizer,\r\n    @Inject(\"BASE_URL\") private baseUrl: string,\r\n  ) {}\r\n\r\n  getDocument(path: string): Observable<DocumentInfo> {\r\n    let docInfo: DocumentInfo;\r\n    const processor = unified()\r\n      .use(markdown, { commonmark: true })\r\n      .use(remarkAttr)\r\n      .use(remarkRehype, { allowDangerousHTML: true })\r\n      .use(raw)\r\n      .use(slug)\r\n      .use(autoLinkHeadings)\r\n      .use(highlight)\r\n      .use(html);\r\n\r\n    return this.http.get<DocumentInfo>(this.baseUrl + path).pipe(\r\n      map(result => {\r\n        // this.baseUrl + pathにアクセスすると、docInfo型のデータがjsonで取得できる。それをそのまま代入。\r\n        docInfo = result;\r\n\r\n        // set default toc\r\n        if (!docInfo.toc) {\r\n          docInfo.toc = \"h2,h3\";\r\n        }\r\n\r\n        // docInfo.bodyはmarkdown形式のデータ。processor.processSync処理でhtmlに変換される\r\n        docInfo.bodyHtml = processor.processSync(docInfo.body).contents;\r\n\r\n        // bypassSecurityTrustHtmlはhtmlデータをSafeHTMLという特別な型に変換する\r\n        docInfo.safeBody = this.sanitizer.bypassSecurityTrustHtml(docInfo.bodyHtml);\r\n        return docInfo;\r\n      }),\r\n    );\r\n  }\r\n  ...\r\n}\r\n```\r\n\r\n**document.component.html(抜粋)**\r\n\r\n```html\r\n<div fxFlex class=\"doc-body\" [innerHTML]=\"docInfo?.bodyHtml\" appRouteTransformer>\r\n```\r\n\r\nまたは\r\n\r\n```html\r\n<div fxFlex class=\"doc-body\" [innerHTML]=\"docInfo?.safeBody\" appRouteTransformer>\r\n```\r\n\r\n通常のhtmlデータ(docInfo.bodyHtml)をinnerHTMLにバインドした場合、idやスタイルなどの属性は自動的に取り除かれてしまいます。またブラウザのコンソール上に**安全でないhtmlデータがバインドされた**という警告が表示されます。\r\n\r\nDomSanitizer.bypassSecurityTrustHtmlを利用すると、htmlデータはSafeHTML型に変換され、Angularはこのデータを無害なhtmlデータとして取り扱います。つまりすべてそのままの状態でバインドされます。\r\n\r\n## ElementRef.nativeElementにバインドする\r\n\r\n実装例を以下に示します。\r\n\r\n**document.component.html(抜粋)**\r\n\r\n```html\r\n<div fxLayout=\"column\" class=\"doc-container\" [@openClose]=\"isOpen ? 'open' : 'closed'\">\r\n  <!-- <p *ngIf=\"!docInfo\">loading...</p> -->\r\n  <ng-container *ngIf=\"docInfo && docInfo?.toc === 'none'\">\r\n    ...\r\n  </ng-container>\r\n  <ng-container *ngIf=\"docInfo && docInfo?.toc !== 'none'\">\r\n    <div fxLayout=\"row\">\r\n      <div fxFlex=\"1 1 85%\" fxFlex.lt-md=\"1 1 100%\">\r\n        <div fxLayout=\"column\">\r\n          ...\r\n          <!-- <div fxFlex class=\"doc-body\" [innerHTML]=\"docInfo?.safeBody\" appRouteTransformer></div> -->\r\n          <div #mdContent fxFlex class=\"doc-body\" appRouteTransformer></div>\r\n        </div>\r\n      </div>\r\n      <div fxFlex=\"1 1 15%\" fxHide.lt-md>\r\n        <app-document-toc [tocList]=\"tocList\" appRouteTransformer></app-document-toc>\r\n      </div>\r\n    </div>\r\n  </ng-container>\r\n</div>\r\n```\r\n\r\n**document.component.ts**\r\n\r\n```ts\r\nimport {\r\n  AfterViewInit,\r\n  ChangeDetectorRef,\r\n  Component,\r\n  ElementRef,\r\n  OnDestroy,\r\n  OnInit,\r\n  ViewChild,\r\n} from '@angular/core';\r\n\r\n@Component({\r\n  selector: \"app-document\",\r\n  templateUrl: \"./document.component.html\",\r\n  styleUrls: [\"./document.component.scss\", \"./vs2015.css\"],\r\n  animations: [defaultRouteAnimation],\r\n})\r\nexport class DocumentComponent implements OnInit, OnDestroy, AfterViewInit {\r\n  docInfo: DocumentInfo | null;\r\n  isOpen: boolean = true;\r\n  tocList: TocItem[] | null;\r\n\r\n  // template html中の<div #mdContent>を参照するオブジェクトを定義\r\n  @ViewChild(\"mdContent\")\r\n  mdRef: ElementRef<HTMLElement>;\r\n\r\n  private fragment: string;\r\n  private previousPath: string;\r\n  private onDestroy = new Subject();\r\n  private routeChangeSubject = new Subject();\r\n\r\n  constructor(\r\n    private markdownService: MarkdownService,\r\n    private location: Location,\r\n    private route: ActivatedRoute,\r\n    private loadingBarService: LoadingBarService,\r\n    private changeDetector: ChangeDetectorRef,\r\n  ) {}\r\n\r\n  ngOnInit() {\r\n    ...\r\n    this.route.url.pipe(takeUntil(this.onDestroy)).subscribe(params => {\r\n      const docRef = params.map(x => x.path).join(\"/\");\r\n      if (docRef !== this.previousPath) {\r\n        this.docInfo = null;\r\n        this.isOpen = false;\r\n        this.getMarkdownDocInfo(docRef);\r\n      } else {\r\n        this.loadingBarService.hide();\r\n      }\r\n      this.previousPath = docRef;\r\n    });\r\n  }\r\n  ...\r\n  private getMarkdownDocInfo(docRef: string) {\r\n    const path = this.location.normalize(\"assets/json/\" + docRef + \".json\");\r\n\r\n    this.markdownService\r\n      .getDocument(path)\r\n      .pipe(takeUntil(this.onDestroy))\r\n      .subscribe(\r\n        doc => {\r\n          this.docInfo = doc;\r\n\r\n          // 初期画面は<ng-container *ngIf=\"docInfo>の条件設定により\r\n          // #mdContentを持つelementがまだ画面にない。\r\n          //\r\n          // this.docInfoをセットした後に、ChangeDetectorRef.detectChanges()することで\r\n          // 仮想DOMの内容が更新され、<ng-container *ngIf=\"docInfo>内のelementに\r\n          // アクセスすることができるようになる。\r\n          this.changeDetector.detectChanges();\r\n\r\n          // mdRef(#mdContentを持つdiv)のnativeElementにアクセスすることで\r\n          // JQueryやjavascriptで過去に行っていたような、htmlタグの操作が可能になる。\r\n          this.mdRef.nativeElement.innerHTML = doc.bodyHtml;\r\n        },\r\n        err => console.error(\"MarkdownService\", err),\r\n      );\r\n  }\r\n  ...\r\n}\r\n```\r\n\r\n`nativeElement`に対する処理はjavascriptで直接実施されるので、safeHTML型にする必要はなく、サニタイズを考慮せずにhtmlをそのままバインドできます（出来てしまいます）。\r\n\r\n## 関連項目\r\n\r\n- [セキュリティ - angular.jp](https://angular.jp/guide/security#bypass-security-apis)\r\n- [ElementRef - angular.jp](https://angular.jp/api/core/ElementRef)\r\n- [\\[Angular\\]変数のバインドで、htmlタグを埋め込む](https://akamist.com/blog/archives/2223)\r\n- [AngularでビューにHTML文書を「バインド」するには？（Property Binding）](https://www.atmarkit.co.jp/ait/articles/1702/13/news127.html)\r\n"}},{"docRef":"/angular/angular-setup-ghpages","content":{"title":"angular-cli-ghpagesを利用する","date":"2019-11-14","category":"Angular","tag":["deploy","github pages"],"body":"\r\n\r\nAngular 7でangular-cli-ghpagesライブラリを利用して、github pagesを簡単に更新できるようなので、その設定方法などを調べました。\r\n\r\n## 実施した手順\r\n\r\nまず初めに[angular-cli-ghpagesのgithubリポジトリ](https://github.com/angular-schule/angular-cli-ghpages)を確認しました。\r\n\r\nPrerequisitesに`Angular project created via Angular CLI v8.3.0-next.0 or greate`と書かれているのを発見。うまくいかないかもしれないが、とりあえずAngular CLI v7系のまま設定を実施しました。\r\n\r\n```bash\r\nPS C:\\Repos\\github\\tech-log\\Website\\ClientApp> ng add angular-cli-ghpages\r\nInstalling packages for tooling via npm.\r\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.7 (node_modules\\fsevents):\r\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.7: wanted {\"os\":\"darwin\",\"arch\":\"any\"} (current: {\"os\":\"win32\",\"arch\":\"x64\"})\r\n+ angular-cli-ghpages@0.5.3\r\nadded 18 packages from 17 contributors and audited 42977 packages in 21.148s\r\nfound 607 vulnerabilities (3 moderate, 604 high)\r\n  run `npm audit fix` to fix them, or `npm audit` for details\r\nInstalled packages for tooling via npm.\r\nThe package that you are trying to add does not support schematics. You can try using a different version of the package or contact the package author to add ng-add support.\r\n```\r\n\r\n警告などが出ている（auditは今後の課題）が、今回は無視して進めます。\r\n\r\n```bash\r\nPS C:\\Repos\\github\\tech-log\\Website\\ClientApp> ng build --prod --base-href \"https://takumura.github.io/tech-log/\"\r\n```\r\n\r\ndry-runによる予行でどのように動くか実験。\r\n\r\n```bash\r\nPS C:\\Repos\\github\\tech-log\\Website\\ClientApp> npx angular-cli-ghpages --dry-run\r\n*** Dry-run: No changes are applied at all.\r\n*** Dry-run / SKIPPED: cleaning of the cache directory\r\n*** Dry-run / SKIPPED: copying of index.html to 404.html\r\n*** Dry-run / SKIPPED: publishing to \"C:\\Repos\\github\\tech-log\\Website\\ClientApp\\dist\" with the following options: { dir: 'C:\\\\Repos\\\\github\\\\tech-log\\\\Website\\\\ClientApp\\\\dist',\r\n  repo:\r\n   'undefined: current working directory (which must be a git repo in this case) will be used to commit & push',\r\n  message: 'Auto-generated commit',\r\n  branch: 'gh-pages',\r\n  user:\r\n   'undefined: local or gloabl git username & email properties will be taken',\r\n  noSilent: 'undefined: logging is in silent mode by default',\r\n  noDotfiles: 'undefined: dotfiles are included by default',\r\n  dryRun: true,\r\n  cname: 'undefined: no CNAME file will be created' }\r\n*** Successfully published!\r\n```\r\n\r\n問題なさそうなので本実行。\r\n\r\n```bash\r\nPS C:\\Repos\\github\\tech-log\\Website\\ClientApp> npx angular-cli-ghpages\r\n```\r\n\r\n初回は`Permission denied (publickey)`エラーが発生してpushに失敗。[Git: githubへのssh接続をSourceTreeからwindows 10標準のssh clientに切り替える](docs/env/git-ssh-configuration){.internal-link}の対応を実施してから再チャレンジ。\r\n\r\n```bash\r\nPS C:\\Repos\\github\\tech-log\\Website\\ClientApp> npx angular-cli-ghpages\r\n*** Successfully published!\r\n```\r\n\r\n無事成功。<https://takumura.github.io/tech-log/> にアクセスすると、見事にサイトが表示されていました。fetchでのjsonデータ取得や、ページ遷移なども問題なく動作しています。素晴らしい！\r\n\r\n## パブリッシュスクリプトの作成\r\n\r\nprodオプション付きのビルドを実行し、生成されたdistフォルダ以下をorigin/gh-pagesにpushするスクリプトを作成しました。\r\n\r\n**publish-to-ghpages.ps1**\r\n\r\n```bash\r\nng build --prod --base-href \"https://takumura.github.io/tech-log/\"\r\nnpx angular-cli-ghpages\r\n```\r\n\r\n## 作業時に参照した情報\r\n\r\n- [Deploying an Angular App to Github Pages](https://alligator.io/angular/deploying-angular-app-github-pages/)\r\n- [Angular-CLIで作成したアプリをGithub Pagesにデプロイする](https://prokatsu.com/angular-cli_github-pages_deploy/)\r\n- [AngularのプロジェクトをGithub Pagesに公開する](https://choco14t.hatenablog.com/entry/2018/07/07/144504)\r\n"}},{"docRef":"/angular/angular-show-gist","content":{"title":"Angularでgistを表示する","date":"2019-11-14","category":"Angular","tag":["gist","embed","postscribe"],"body":"\r\n\r\n[Angularで動的にHTMLタグをコンポーネントに埋め込む](docs/angular/angular-embed-html-tag){.internal-link}により、htmlを埋め込むことができたが、その中にscriptタグが含まれていた場合、表示させただけではscriptが実行されません。JQueryでいうところの`$()`に相当する、画面描画後にscriptを実行する処理が必要になります。\r\n\r\n本tech-log内で、gistのembedを表示するのに本課題を対応する必要があり、解決方法を調査しました。\r\n\r\n## PostScribeを利用する\r\n\r\n非同期にscriptを実行し、結果をDOMに書き込む[PostScribe](https://krux.github.io/postscribe/)というライブラリを利用することで、gistのembedを実現しました。\r\n\r\n**Markdownファイル(抜粋)**\r\n\r\n```html\r\ngistの表示デモ。class=\"gist\"のdivでgistのembedスクリプトを囲います\r\n<div class=\"gist\">\r\n  <script src=\"https://gist.github.com/takumura/bbff68078afb2d0846773965d1678c7c.js\"></script>\r\n</div>\r\n```\r\n\r\n**document.component.ts（抜粋）**\r\n\r\n```ts\r\nimport {\r\n  AfterViewInit,\r\n  ChangeDetectorRef,\r\n  Component,\r\n  ElementRef,\r\n  OnDestroy,\r\n  OnInit,\r\n  ViewChild,\r\n} from '@angular/core';\r\nimport postscribe from 'postscribe';\r\n\r\n@Component({\r\n  selector: \"app-document\",\r\n  templateUrl: \"./document.component.html\",\r\n  styleUrls: [\"./document.component.scss\", \"./vs2015.css\"],\r\n  animations: [defaultRouteAnimation],\r\n})\r\nexport class DocumentComponent implements OnInit, OnDestroy, AfterViewInit {\r\n  docInfo: DocumentInfo | null;\r\n  isOpen: boolean = true;\r\n  tocList: TocItem[] | null;\r\n\r\n  // template html中の<div #mdContent>を参照するオブジェクトを定義\r\n  @ViewChild(\"mdContent\")\r\n  mdRef: ElementRef<HTMLElement>;\r\n\r\n  private fragment: string;\r\n  private previousPath: string;\r\n  private onDestroy = new Subject();\r\n  private routeChangeSubject = new Subject();\r\n\r\n  constructor(\r\n    private markdownService: MarkdownService,\r\n    private location: Location,\r\n    private route: ActivatedRoute,\r\n    private loadingBarService: LoadingBarService,\r\n    private changeDetector: ChangeDetectorRef,\r\n  ) {}\r\n\r\n  ngOnInit() {\r\n    ...\r\n    this.route.url.pipe(takeUntil(this.onDestroy)).subscribe(params => {\r\n      const docRef = params.map(x => x.path).join(\"/\");\r\n      if (docRef !== this.previousPath) {\r\n        this.docInfo = null;\r\n        this.isOpen = false;\r\n        this.getMarkdownDocInfo(docRef);\r\n      } else {\r\n        this.loadingBarService.hide();\r\n      }\r\n      this.previousPath = docRef;\r\n    });\r\n  }\r\n  ...\r\n  private getMarkdownDocInfo(docRef: string) {\r\n    const path = this.location.normalize('assets/json/' + docRef + '.json');\r\n\r\n    this.markdownService\r\n      .getDocument(path)\r\n      .pipe(takeUntil(this.onDestroy))\r\n      .subscribe(\r\n        doc => {\r\n          this.docInfo = doc;\r\n\r\n          // detect change to update virtual DOM\r\n          // and allow to access mdContentRef\r\n          this.cdRef.detectChanges();\r\n          this.mdContentRef.nativeElement.innerHTML = this.docInfo.bodyHtml;\r\n\r\n          this.showGist();\r\n          this.generateToc();\r\n          this.routeChangeSubject.next();\r\n        },\r\n        err => console.error('MarkdownService', err),\r\n      );\r\n  }\r\n\r\n  private showGist() {\r\n    const gists = this.mdContentRef.nativeElement.querySelectorAll('div.gist');\r\n    gists.forEach(gist => {\r\n      postscribe(gist, gist.innerHTML);\r\n    });\r\n  }\r\n  ...\r\n}\r\n```\r\n\r\n`this.mdContentRef.nativeElement.innerHTML = this.docInfo.bodyHtml;`でhtmlをDOMに反映させた後で、`showGist()`関数を呼んでいます。\r\n\r\n`showGist`関数では、`this.mdContentRef.nativeElement.querySelectorAll('div.gist')`で`gist`クラスを持つ`div`タグをリストアップし、発見したすべての`div`に対して`div.innerHTML`、すなわちembedのscriptを実行しています。\r\n\r\n```ts\r\npostscribe(\r\n  gist,           // div.gistのtag。このdivの中にscript実行結果が書き込まれる。\r\n  gist.innerHTML  // div.innerHTML = gistのembed script\r\n);\r\n```\r\n\r\n## 関連項目\r\n\r\n- [postscribe - Github](https://github.com/krux/postscribe)\r\n- [VSCode: Settings Syncで環境設定を共有する](docs/env/vscode-settings-sync){.internal-link}\r\n"}},{"docRef":"/angular/angular_prerender","content":{"title":"Angularのプリレンダリングについて","date":"2020-02-15","category":"Angular","tag":["prerender"],"body":"[angular-prerender](https://github.com/chrisguttandin/angular-prerender)という気になるツールを見かけたので、使ったらどうなるのか試してみます。\r\n\r\n## 環境の準備\r\n\r\n### nodejs\r\n\r\nLTS版のnodeを利用します。これまではWindows installerでインストールしていましたが、今回kらscoopを使うようにしました。\r\n\r\n``` ps\r\n> scoop install nodejs-lts\r\nInstalling 'nodejs-lts' (12.16.0) [64bit]\r\nnode-v12.16.0-win-x64.7z (10.2 MB) [=============================] 100%\r\nChecking hash of node-v12.16.0-win-x64.7z ... ok.\r\nExtracting node-v12.16.0-win-x64.7z ... done.\r\nLinking C:\\Apps\\scoop\\apps\\nodejs-lts\\current => C:\\Apps\\scoop\\apps\\nodejs-lts\\12.16.0\r\nPersisting bin\r\nPersisting cache\r\nRunning post-install script...\r\n'nodejs-lts' (12.16.0) was installed successfully!\r\n\r\n> node -v\r\nv12.16.0\r\n```\r\n\r\nwindowsのアンインストールでは`%AppData%/npm`と`%AppData%/npm-cache`が削除されず残ってしまうことがありました。見つけたら手動で削除します。\r\n\r\n### package manager\r\n\r\n2020年2月の調査でもnpmよりyarnの方がパフォーマンスが良いという記事が多いので、package managerにはnpmではなくyarnを使用します。scoopを使ってインストールします。\r\n\r\n```ps\r\n> scoop install yarn\r\n```\r\n\r\n### Angular CLI\r\n\r\nAngularのバージョンは9を利用することにします。これまではAngular7を使っていて、今回初めて9のプロジェクトを作るので、Angular CLIの更新から始めます。\r\n\r\nyarn globalインストールでは、versionがうまく表示されないエラーがあるようなので、npmでグローバルインストールします。\r\n\r\n```ps\r\n> npm uninstall -g angular-cli\r\n> npm cache verify\r\n> npm install -g @angular/cli@latest\r\n> ng version\r\n\r\n     _                      _                 ____ _     ___\r\n    / \\   _ __   __ _ _   _| | __ _ _ __     / ___| |   |_ _|\r\n   / △ \\ | '_ \\ / _` | | | | |/ _` | '__|   | |   | |    | |\r\n  / ___ \\| | | | (_| | |_| | | (_| | |      | |___| |___ | |\r\n /_/   \\_\\_| |_|\\__, |\\__,_|_|\\__,_|_|       \\____|_____|___|\r\n                |___/\r\n\r\nAngular CLI: 9.0.2\r\nNode: 12.16.0\r\nOS: win32 x64\r\n\r\nAngular:\r\n...\r\nIvy Workspace:\r\n\r\nPackage                      Version\r\n------------------------------------------------------\r\n@angular-devkit/architect    0.900.2\r\n@angular-devkit/core         9.0.2\r\n@angular-devkit/schematics   9.0.2\r\n@schematics/angular          9.0.2\r\n@schematics/update           0.900.2\r\nrxjs                         6.5.3\r\n```\r\n\r\n## プロジェクトの作成\r\n\r\nangular prerender公式サイトの手順通りに進めます。\r\n\r\n```ps\r\n> ng config -g cli.packageManager yarn\r\n> ng new universe --routing\r\n```\r\n\r\n初回実行時にpackageの解決まで行われるので、事前にAngular CLIが利用するpackage managerをyarnに変更してから、新規にAngular9 appを作成しました。\r\n\r\n## universal(server) moduleの作成\r\n\r\n```ps\r\n> cd universe\r\n> ng generate universal --client-project universe\r\nCREATE src/main.server.ts (298 bytes)\r\nCREATE src/app/app.server.module.ts (318 bytes)\r\nCREATE tsconfig.server.json (308 bytes)\r\nUPDATE package.json (1327 bytes)\r\nUPDATE angular.json (4357 bytes)\r\nUPDATE src/main.ts (432 bytes)\r\nUPDATE src/app/app.module.ts (438 bytes)\r\n√ Packages installed successfully.\r\n```\r\n\r\n## angular-prerenderの導入とprerender処理\r\n\r\n```ps\r\n> yarn add angular-prerender --dev\r\n> ng build\r\n> ng run universe:server\r\n> npx angular-prerender\r\n```\r\n\r\n処理が正常に終了し、`dist\\universe\\browser\\index.html`にapp.component.htmlの内容が追記されていることを確認しました。\r\n\r\n## 次にやること\r\n\r\nrouteを増やして、どのようにhtmlが追記されるのかを確認します。\r\n\r\n## 作業録\r\n\r\nステップ毎の変更点を<https://github.com/takumura/angular-express-prerender/commits/master>から確認できます。\r\n\r\n## 関連項目\r\n\r\n- [Angular Update Guide](https://update.angular.io/)\r\n- [Updating to Angular version 9](https://angular.io/guide/updating-to-version-9)\r\n- [Angularの環境構築（Angular CLIで構築）](https://qiita.com/Yamamoto0525/items/65d5a0b36eb4dbd8079b)"}},{"docRef":"/blazor/build-first-blazor-webassembly-app","content":{"title":"Blazor WebAssemblyアプリを作成する","date":"2020-05-05","category":"Blazor","tag":["overview","webassembly","demo"],"body":"NET5でproduction readyになる予定のBlazor WebAssemblyの情報収集と、空のアプリ作成を作成してみる。\r\n\r\n## 情報収集\r\n\r\nMS Docsにある[チュートリアル - 最初の Blazor アプリをビルドする](https://docs.microsoft.com/ja-jp/aspnet/core/tutorials/build-your-first-blazor-app?view=aspnetcore-3.1)を試してみる事にします。\r\n\r\n注意書きには\".NET Core 3.1ではプレビュー段階である\"と書いてあるので、NET5になったら手順等改めて振り返る必要がありそうです。\r\n\r\n```plaintext\r\nプレビュー段階の Blazor WebAssembly\r\n\" Blazor サーバー\" は ASP.NET Core 3.0 でサポートされています。 \" Blazor WebAssembly\" は、ASP.NET Core 3.1 のプレビュー段階です。\r\n```\r\n\r\nまた[ASP.NET Core Blazor の概要](https://docs.microsoft.com/ja-jp/aspnet/core/blazor/get-started?view=aspnetcore-3.1&tabs=visual-studio)には、\r\n\r\n```plaintext\r\nBlazor WebAssembly エクスペリエンス (Visual Studio 16.6 Preview 2 以降) については、 [Blazor WebAssembly アプリ] テンプレートを選択します。\r\n````\r\n\r\nと記載されているので、Visual Studioで開発を行う場合は16.6以降が必要なようです。\r\n\r\n今日(2020-05-05)時点の最新は16.5.4だったので、Visual Studio 2019 Previewをインストールして開発に使用します。\r\n\r\nまた、以下のコマンドを実行して、テンプレートをインストールします。実行前にプロジェクトを作成してもBlazorサーバテンプレートしか表示されず、Blazor WebAssemblyプロジェクトを開始できませんでした。\r\n\r\n```ps\r\n> dotnet new -i Microsoft.AspNetCore.Components.WebAssembly.Templates::3.2.0-preview5.20216.8\r\n```\r\n\r\n実行後の利用可能なテンプレートは以下の通り。\r\n\r\n```plaintext\r\nTemplates                                         Short Name               Language          Tags\r\n----------------------------------------------------------------------------------------------------------------------------------\r\nConsole Application                               console                  [C#], F#, VB      Common/Console\r\nClass library                                     classlib                 [C#], F#, VB      Common/Library\r\nWPF Application                                   wpf                      [C#]              Common/WPF\r\nWPF Class library                                 wpflib                   [C#]              Common/WPF\r\nWPF Custom Control Library                        wpfcustomcontrollib      [C#]              Common/WPF\r\nWPF User Control Library                          wpfusercontrollib        [C#]              Common/WPF\r\nWindows Forms (WinForms) Application              winforms                 [C#]              Common/WinForms\r\nWindows Forms (WinForms) Class library            winformslib              [C#]              Common/WinForms\r\nWorker Service                                    worker                   [C#]              Common/Worker/Web\r\nUnit Test Project                                 mstest                   [C#], F#, VB      Test/MSTest\r\nNUnit 3 Test Project                              nunit                    [C#], F#, VB      Test/NUnit\r\nNUnit 3 Test Item                                 nunit-test               [C#], F#, VB      Test/NUnit\r\nxUnit Test Project                                xunit                    [C#], F#, VB      Test/xUnit\r\nRazor Component                                   razorcomponent           [C#]              Web/ASP.NET\r\nRazor Page                                        page                     [C#]              Web/ASP.NET\r\nMVC ViewImports                                   viewimports              [C#]              Web/ASP.NET\r\nMVC ViewStart                                     viewstart                [C#]              Web/ASP.NET\r\nBlazor Server App                                 blazorserver             [C#]              Web/Blazor\r\nBlazor WebAssembly App                            blazorwasm               [C#]              Web/Blazor/WebAssembly\r\nASP.NET Core Empty                                web                      [C#], F#          Web/Empty\r\nASP.NET Core Web App (Model-View-Controller)      mvc                      [C#], F#          Web/MVC\r\nASP.NET Core Web App                              webapp                   [C#]              Web/MVC/Razor Pages\r\nASP.NET Core with Angular                         angular                  [C#]              Web/MVC/SPA\r\nASP.NET Core with React.js                        react                    [C#]              Web/MVC/SPA\r\nASP.NET Core with React.js and Redux              reactredux               [C#]              Web/MVC/SPA\r\nRazor Class Library                               razorclasslib            [C#]              Web/Razor/Library/Razor Class Library\r\nASP.NET Core Web API                              webapi                   [C#], F#          Web/WebAPI\r\nASP.NET Core gRPC Service                         grpc                     [C#]              Web/gRPC\r\ndotnet gitignore file                             gitignore                                  Config\r\nglobal.json file                                  globaljson                                 Config\r\nNuGet Config                                      nugetconfig                                Config\r\nDotnet local tool manifest file                   tool-manifest                              Config\r\nWeb Config                                        webconfig                                  Config\r\nSolution File                                     sln                                        Solution\r\nProtocol Buffer File                              proto                                      Web/gRPC\r\n```\r\n\r\n`Blazor WebAssembly App`テンプレートを選択すると、`ASP.NET Core hosted`と`Progressive Web Application`のチェックボックスが表示されました。\r\n\r\n`ASP.NET Core hosted`については[ASP.NET Core Blazor のホスティング モデル](https://docs.microsoft.com/ja-jp/aspnet/core/blazor/hosting-models?view=aspnetcore-3.1)に詳細が書かれており、チェックするとBlazorサーバと同様にサーバ側で処理が行われるようになるので、チェックしないことにしました。\r\n\r\n`Progressive Web Application`については[ASP.NET Core Blazor WebAssembly を使用してプログレッシブ Web アプリケーションをビルドする](https://docs.microsoft.com/ja-jp/aspnet/core/blazor/progressive-web-app?view=aspnetcore-3.1&tabs=visual-studio)に記載があり、チェックすることで何も損しなさそうなので、チェックをしてプロジェクトを作成しました。\r\n\r\nプロジェクト作成後、`F5`キーで実行すると、問題なくBlazor WebAssemblyアプリが起動しました。Chrome DevToolsでネットワークリソースを確認したところ、6.5MBと噂通り巨大なアプリサイズです（これでも少なくなったらしいですが）。\r\n\r\n```ps\r\n68 requests, 6.5MB transferred, 18.0MB resources, Finish: 3.51s, DOMContentLoaded: 282ms, Load:291ms\r\n```\r\n\r\n2度目のページ取得ではだいぶ軽くなります。\r\n\r\n```ps\r\n11 requests, 171kB transferred 508kB resources, Finish:1.63s, DOMContentLoaded: 359ms, Load:361ms\r\n```\r\n\r\nその後、todoページの作成まで一通り写経して、Blazorの基礎の基礎を理解しました。スタイルを一切変えていないので、見た目は少しヘンテコリンです。\r\n\r\nデフォルトテンプレートはbootstrap4のcssで装飾されています。公式のFluent Design実装はまだなく、[open issue](https://github.com/dotnet/aspnetcore/issues/11229)で議論されているようです。\r\n\r\n## 関連項目\r\n\r\n- [Awesome Blazor](https://awesomeopensource.com/project/AdrienTorris/awesome-blazor)"}},{"docRef":"/env/git-ssh-configuration","content":{"title":"Git: githubへのssh接続をSourceTreeからwindows 10標準のssh clientに切り替える","date":"2019-08-15","category":"環境設定","tag":["git","vscode","openssh","windows10"],"body":"## 経緯\r\n\r\n- これまではSourceTreeを利用してGithub, Bitbucketのリモートリポジトリを操作していました\r\n- 接続にはsshを利用し、SourceTreeに付属のPuttyおよびPageantで鍵の運用をしていました\r\n- [angular-cli-ghpagesを利用する](docs/angular/angular-setup-ghpages){.internal-link}の作業で、origin/gh-pagesにpushする処理でエラーが発生\r\n- VSCodeをPutty(Pageant)を連携する方法を調べたが見つからず、ssh clientの利用方法を見直す必要がありました\r\n\r\n## 環境\r\n\r\n- Windows 10 May 2019 Update(バージョン1903)\r\n- SourceTree 3.1.3\r\n\r\n## 実施した手順\r\n\r\nまず初めに、VSCodeからssh接続でremoteにpushする方法について、google検索で情報収集しました。Puttyを利用している記事はヒットせず、openssh clientの設定を行う記事が大半でした。\r\n\r\n開発環境はWindows 10 May 2019 Update(バージョン1903)が適用済みで、特に設定不要でssh clientが利用可能になっていました。なのでこれを利用することにします。\r\n\r\n途中までSourceTreeで作業をしていたので、鍵の作成や公開鍵のgithubへの登録は完了済みでした。なのでssh clientに秘密鍵を登録して使えるようにします。\r\n\r\n### OpenSSH Authentication Agentサービスの設定変更\r\n\r\nOpenSSH Authentication Agentサービスは無効状態でした。サービスを起動し、設定を自動起動に変更しました。\r\n\r\n### ppkファイルからOpenSSH形式の秘密鍵を生成\r\n\r\nPutty(Pageant)が利用している秘密鍵(.ppk)はOpenSSHと互換性のない独自形式です。ssh clientで利用するためにはOpenSSH形式に変換してあげる必要があります。\r\n\r\n1. SourceTreeのメニューから`SSH キーの生成/インポート`を選択\\\r\n    <img src=\"assets/images/git-ssh-configuration/git-ssh-configuration-1.png\" alt=\"puttygen.exe\" title=\"puttygen.exe\">\r\n\r\n2. Loadボタンを押して、githubの秘密鍵(.ppk)を読み込み、メニュの`Conversions` > `Export OpenSSH key`を選択。OpenSSh形式の秘密鍵: `id_rsa`を生成\r\n3. 作成した`id_ras`ファイルを`c:\\Users\\<username>\\.ssh`フォルダに配置\r\n\r\n1.で実行されるツール(puttygen.exe)は、私の環境では`c:\\Users\\<username>\\AppData\\Local\\SourceTree\\app-3.1.3\\tools\\putty\\puttygen.exe`にありました。\r\n\r\n`c:\\Users\\<username>\\.ssh`も存在していましたが、中身は空でした。\r\n\r\n### ssh-agentに秘密鍵を登録\r\n\r\n以下のコマンドを実行します。\r\n\r\n```cmd\r\n> cd c:\\Users\\<username>\\.ssh\r\n> ssh-add id_rsa\r\n```\r\n\r\nパスフレーズを聞かれるので、正しく入力すると登録が完了しました。\r\n\r\nこれで、gitコマンドを使ってリモートリポジトリを操作できるようになりました。\r\n\r\n## SourceTreeの併用について\r\n\r\nこれまで通りSourceTreeも併用していきたいので、鍵の管理フォルダを`c:\\Users\\<username>\\.ssh`に変更しました。\r\n\r\nそして、これまで鍵長2048でキーを作成していることに気が付いたので、鍵長4096のキーにすべて置き換えることにしました。\r\n\r\nBitbucket用、Github用に別々のキーを作成して管理していましたが、今回はAzure DevOpsを含めた3つのgitリポジトリへのアクセスを、共通した1つの鍵で管理することにしました。\r\n\r\n```cmd\r\n.ssh> dir\r\n\r\nMode                LastWriteTime         Length Name\r\n----                -------------         ------ ----\r\n-a----       2019/08/15     14:11           3311 id_rsa\r\n-a----       2019/08/15     14:10           2719 id_rsa.ppk\r\n-a----       2019/08/15     15:13            739 id_rsa.pub\r\n-a----       2019/08/15     15:49           4377 known_hosts\r\n```\r\n\r\n## 作業時に参照した情報\r\n\r\n- [PuTTYを卒業してWindows 10標準のssh client（ベータ）に切り替えた](http://www.freia.jp/taka/blog/windows-native-ssh-client/index.html)\r\n- [Use SSH key authentication](https://docs.microsoft.com/en-us/azure/devops/repos/git/use-ssh-keys-to-authenticate?view=azure-devops)"}},{"docRef":"/env/tool-list","content":{"title":"Windowsの環境セットアップ","date":"2019-11-08","category":"環境設定","tag":["setup","tool","install"],"body":"\r\n\r\nWindowsの環境セットアップ手順についてまとめます。Scoopを利用できるものはセットアップを自動化し、そうでないものは個別にインストールしています。\r\n\r\n## scoopを用いた環境セットアップスクリプト\r\n\r\n**env-setup-common.ps1**\r\n\r\n```ps\r\n## plese run following command if error occured for running powershell script.\r\n## set-executionpolicy unrestricted -s cu\r\n\r\n# install scoop to \"c:\\Apps\\scoop\" folder\r\n$env:SCOOP='C:\\Apps\\scoop'\r\n[environment]::setEnvironmentVariable('SCOOP',$env:SCOOP,'User')\r\nInvoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh')\r\n\r\n# install git to add bucket\r\nscoop install git\r\n\r\n# add extras bucket\r\nscoop bucket add extras\r\n\r\n# utils\r\nscoop install 7zip keepass curl winmerge fiddler\r\n```\r\n\r\n**env-setup-dev.ps1**\r\n\r\n```ps\r\n# dev utils\r\nscoop install git fork\r\n\r\n# programming\r\nscoop install dotnet-sdk nodejs\r\n\r\n# editor\r\nscoop install vscode\r\n```\r\n\r\n### 7zip\r\n\r\n圧縮・解凍ソフト。Scoopを利用してインストールできます。完了後に、`scoop\\apps\\7zip\\current\\7zFM.exe`のメニュ > `ツール` > `オプション` > `7-Zip` から `シェルコンテキストメニュに7zipを登録`のチェックを入れて、右クリックメニュから7zipを使えるようにします。\r\n\r\n### keepass\r\n\r\nパスワード管理ツール。\r\n\r\n### curl\r\n\r\nURLシンタックスを用いてファイル送受信を行うコマンドラインツール\r\n\r\n### git\r\n\r\nバージョン管理ツール\r\n\r\n### git-fork\r\n\r\nグラフィカルgitクライアント。一緒に仕事をしている人が超絶お勧めしているので試してみる予定。Scoopを利用してインストールできるか検討中。\r\n\r\n### WinMerge\r\n\r\n差分比較、マージツール。Scoopを利用してインストールできます。\r\n\r\n### fiddler\r\n\r\nHTTPトラフィック監視ツール。Scoopを利用してインストールできるか検討中。\r\n\r\n### Simple VHD Manager\r\n\r\nVHD（仮想ハードディスク）ファイルの管理ツール。Scoopを利用してインストールできるか検討中。公式bucketsにはapp manifestが存在しないため、自分で作る必要がある。\r\n\r\n### .NET Core\r\n\r\n開発環境。Scoopを利用してインストールできるか検討中。\r\n\r\n### Nodejs\r\n\r\n開発環境。Scoopを利用してインストールできるか検討中。LTS版をインストールする予定。\r\n\r\n### Visual Studio Code\r\n\r\n軽量コードエディター。Scoopを利用してインストールできるか検討中。\r\n\r\n### chrome\r\n\r\nブラウザ。Scoopを利用してインストールできるか検討中。公式bucketsにはapp manifestが存在しないため、自分で作る必要がある。\r\n\r\n## 個別にインストールするAppについて\r\n\r\n### Synkron\r\n\r\nフォルダ同期ツール\r\n\r\n### Visual Studio\r\n\r\n開発環境\r\n\r\n## 関連項目\r\n\r\n- [Example Setup Scripts](https://github.com/lukesampson/scoop/wiki/Example-Setup-Scripts)\r\n- [Chrome.json](https://github.com/Ash258/scoop-Ash258/blob/master/bucket/Chrome.json)\r\n- [SimpleVHDManager.json](https://github.com/Ash258/scoop-Ash258/blob/master/bucket/SimpleVHDManager.json)\r\n"}},{"docRef":"/env/update-markdown-from-ios","content":{"title":"Githubで管理しているmarkdownをiPhoneから更新する","date":"2020-02-12","category":"環境設定","tag":["開発","markdown","ios"],"body":"\r\n\r\n帰宅中はやる気があるのに、自宅に帰るとまったりしてしまい、お勉強が捗らない今日この頃。まだやる気の残っている通勤中に記事を更新するのが時間効率的にもベストだろう。ということで、iPhoneからGithubのリポジトリを操作して、markdownの記事を更新する方法を模索します。\r\n\r\nGithubの操作にはWorking Copyを、markdownエディタにはTypeをそれぞれ選びました。\r\n\r\n## Working Copy\r\n\r\nApp Storeからダウンロードして開くと、`Repositories`の画面が表示されます。左上の歯車iconは設定、右上の`+`がリポジトリ操作のメニュでした。設定のいくつかはappの購入(2440円)が必要なようです。remoteへのpushが優良らしいので最終的には購入必須ですが、10日間のtrialがあるのでまずはそれから試す予定です。\r\n\r\nリポジトリ操作メニュの`Clone repository` > `Github`を選ぶとGithubへのログオンが要求されます。ログオンが完了するとssh keyが自動で作成、登録されました。改めてクローンしたいレポジトリを選択したら、何事もなくファイルがiPhoneにクローンされました。\r\n\r\nクローンしたファイルは、iOS標準のファイルアプリから参照することができました。クローン完了後にファイルアプリを開き、右上`・・・` > `編集`を選ぶと、`場所`欄にiCloud DriveやOneDriveと並んでWorking Copyが表示されます。デフォルトでは表示がオフになっているので、これをオンにするとクローンしたファイルが見えるようになりました。\r\n\r\n## Type\r\n\r\n利用は無料、独自クラウドへのデータ同期が有料なmarkdownエディタ。シンプルで使いやすそうなインタフェースだったので選びました。\r\n\r\nファイルアプリへのアクセスが可能で、Working Copyがクローンしたファイルにアクセス出来ることを確認しました。Typeのapp購入は不要そうです。\r\n\r\n## 気になったこと\r\n\r\nこの二つのappを使って、通勤中の作業をしばらく試してみようと思います。試しにmarkdownファイルをTypeで見ていたところ、改行コードの違いがdiffに出ていることに気が付きました。VSCodeでの改行コードをCRLFからLFにした方が良いかもしれません。色々試しながら調整していこうと思います。\r\n"}},{"docRef":"/env/use-scoop","content":{"title":"scoopでWindowsアプリを管理する","date":"2019-11-01","category":"環境設定","tag":["tool","scoop"],"body":"\r\n\r\nscoopを利用して、開発環境の自動セットアップ、および最新版への定期的なアップデートなどの管理を上手に行えるのか試してみます。\r\n\r\n## インストール\r\n\r\nまず初めに[公式サイト](https://scoop.sh/)と[GitHub リポジトリ](https://github.com/lukesampson/scoop)を確認しました。インストールはPowerShellスクリプトで行うと書いてあるので、その通りに実行しました。\r\n\r\n```ps\r\n> Invoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh')\r\nInitializing...\r\nDownloading scoop...\r\nExtracting...\r\nCreating shim...\r\nDownloading main bucket...\r\nExtracting...\r\nAdding ~\\scoop\\shims to your path.\r\n'lastupdate' has been set to '2019-11-01T17:22:42.8161465+09:00'\r\nScoop was installed successfully!\r\nType 'scoop help' for instructions.\r\n```\r\n\r\nログインしているアカウントのユーザフォルダ以下に`scoop`フォルダが作成されました。scoopで管理されるAppはこのフォルダ以下に配置されるようです。\r\n\r\n## Bucket の設定\r\n\r\nデフォルトではmain backetが利用可能です。`bucket add`コマンドにより、bucketを追加することができます。追加可能な bucketは`scoop\\apps\\scoop\\current\\buckets.json`で設定されており、`bucket known`コマンドで見る事もできます。\r\n\r\n```ps\r\n> scoop bucket known\r\nmain\r\nextras\r\nnightlies\r\nnirsoft\r\nphp\r\nnerd-fonts\r\nnonportable\r\njava\r\ngames\r\njetbrains\r\n```\r\n\r\n以前から利用しているAppがextrasにありそうだったので、追加しました。\r\n\r\n```ps\r\n> scoop bucket add extras\r\nChecking repo... ok\r\nThe extras bucket was added successfully.\r\n```\r\n\r\ngitがインストールされていないとbucketの追加に失敗します。その場合はgitを先にインストールします。\r\n\r\n```ps\r\nscoop install git\r\n```\r\n\r\n## よく使うであろうコマンド\r\n\r\n### scoop search\r\n\r\n指定したAppがBucket(collections of apps)にあるか検索する。\r\n\r\n```ps\r\n> scoop search nodejs\r\n'main' bucket:\r\n    nodejs-lts (12.13.0)\r\n    nodejs (13.1.0)\r\n\r\n> scoop search keepass\r\n'extras' bucket:\r\n    keepass-plugin-keeagent (0.10.1)\r\n    keepass-plugin-keeanywhere (1.5.1)\r\n    keepass-plugin-keepassnatmsg (2.0.6)\r\n    keepass-plugin-keepassrpc (1.9.0)\r\n    keepass-plugin-keetraytotp (0.99-Beta)\r\n    keepass-plugin-sequencer (0.1.1)\r\n    keepass-plugin-yafd (1.2.2.0)\r\n    keepass (2.43)\r\n    keepassxc (2.5.0)\r\n```\r\n\r\n### scoop install\r\n\r\n指定したAppをインストールする。\r\n\r\n```ps\r\n> scoop install 7zip\r\nUpdating Scoop...\r\nUpdating 'main' bucket...\r\nChecking repo... ok\r\nThe main bucket was added successfully.\r\nScoop was updated successfully!\r\nInstalling '7zip' (19.00) [64bit]\r\n7z1900-x64.msi (1.7 MB) [===============================================================================================] 100%\r\nChecking hash of 7z1900-x64.msi ... ok.\r\nExtracting 7z1900-x64.msi ... done.\r\nLinking ~\\scoop\\apps\\7zip\\current => ~\\scoop\\apps\\7zip\\19.00\r\nCreating shim for '7z'.\r\nCreating shortcut for 7-Zip (7zFM.exe)\r\n'7zip' (19.00) was installed successfully!\r\n```\r\n\r\n## scoop update\r\n\r\n`scoop udpate`コマンドでscoop自体とインストール可能なAppの情報（app manifest）を更新できます。セミコロンで続けて`scoop update *`とすることで、インストール済みのすべてのAppに対して、バージョンアップのチェックおよびAppの更新ができます。\r\n\r\n```ps\r\n> scoop update; scoop update *\r\nUpdating Scoop...\r\nUpdating 'extras' bucket...\r\n * 4366eadd vscodium: Update to version 1.40.0                           2 hours ago\r\n * 3ade6589 vscodium-portable: Update to version 1.40.0                  2 hours ago\r\n * 88e85c64 vivaldi: Update to version 2.9.1705.41                       2 hours ago\r\nUpdating 'main' bucket...\r\n * 124c0c6a ffmpeg-nightly: Update to version 20191108-e700038           2 hours ago\r\n * 20998cde annie: Update to version 0.9.6                               2 hours ago\r\n * 41fcafae terraform-provider-ibm: Update to version 0.19.0             3 hours ago\r\n * 94629c47 jx: Update to version 2.0.971                                3 hours ago\r\n * b017d181 faas-cli: Update to version 0.10.3                           3 hours ago\r\nScoop was updated successfully!\r\nLatest versions for all apps are installed! For more information try 'scoop status'\r\n```\r\n\r\n## アンインストール\r\n\r\n追加でインストールするAp は`C:\\Apps`以下にまとめるルールにしていたので、scoopをインストールし直すことにします。\r\n\r\n```ps\r\n> scoop uninstall scoop\r\nWARN  This will uninstall Scoop and all the programs that have been installed with Scoop!\r\nAre you sure? (yN): y\r\nUninstalling '7zip'\r\nRemoving shim for '7z'.\r\nWARN  Couldn't remove ~\\scoop\\apps\\7zip: 項目 C:\\Users\\takum\\scoop\\apps\\7zip\\19.00\\7-zip.dll を削除できません: パス '7-zip.dll' へのアクセスが拒否されました。.Exception\r\nUninstalling 'winmerge'\r\nRemoving shim for 'WinMergeU'.\r\nCouldn't remove ~\\scoop\\apps: 項目 C:\\Users\\takum\\scoop\\apps\\7zip\\19.00\\7-zip.dll を削除できません: パス '7-zip.dll'\r\nへのアクセスが拒否されました。\r\n```\r\n\r\n7zipインストール後にエクスプローラ統合の設定をしたために`7-zip.dll`が削除できなくなっていました。設定を解除して再起動後、アンインストールをやり直します。\r\n\r\n```ps\r\nscoop uninstall scoop\r\nWARN  This will uninstall Scoop and all the programs that have been installed with Scoop!\r\nAre you sure? (yN): y\r\nUninstalling '7zip'\r\nWARN  Shim for '7z' is missing. Skipping.\r\nRemoving ~\\scoop\\shims from your path.\r\nScoop has been uninstalled.\r\n```\r\n\r\n今度は正常にアンインストール処理が完走しました。\r\n\r\n## カスタムディレクトリに scoop をインストール\r\n\r\n公式wikiの[Installing Scoop to Custom Directory](https://github.com/lukesampson/scoop/wiki/Quick-Start#installing-scoop-to-custom-directory)を参考にして、`C:\\Apps\\scoop`以下にscoopをインストールします。\r\n\r\n```ps\r\n$env:SCOOP='C:\\Apps\\scoop'\r\n[environment]::setEnvironmentVariable('SCOOP',$env:SCOOP,'User')\r\nInvoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh')\r\n```\r\n\r\n## App Manifest について\r\n\r\n公式が提供していないApp Manifestは自分で作ることも可能です。詳細な方法は[Creating an app manifest](https://github.com/lukesampson/scoop/wiki/Creating-an-app-manifest)に書かれています。\r\n\r\n## 作業時に参照した情報\r\n\r\n[scoop wiki - GitHub](https://github.com/lukesampson/scoop/wiki)\r\n"}},{"docRef":"/env/vscode-settings-sync","content":{"title":"VSCode: Settings Syncで環境設定を共有する","date":"2019-11-01","category":"環境設定","tag":["vscode","git","settings.json"],"body":"\r\n\r\n拡張機能: `Settings Sync`を導入することで、VSCodeの設定、スニペット、テーマ、ファイルアイコン、キーバインディング、ワークスペース、拡張機能を複数のマシンで同期できます。\r\n\r\nデータはgistで共有されることになるので、設定のバックアップにもなりそうです。\r\n\r\n## 手順\r\n\r\nまずはSettings Syncの拡張機能画面で、設定方法の解説を確認。\r\n\r\n```plaintext\r\nShortcuts\r\n    1. Upload Key : Shift + Alt + U\r\n    2. Download Key : Shift + Alt + D\r\n\r\nConfigure Settings Sync\r\n    Settings Sync Configuration page will be opened automatically on code start and requires two things to setup:\r\n\r\n    1. GitHub Token\r\n    2. GitHub Gist Id\r\n\r\n    GitHub Token needs to be retrived by your GitHub account while Settings Sync creates GIST if you are first time user.\r\n\r\n    Following are the steps you need to perform to configure.\r\n\r\n    - Click on Login with GitHub .\r\n    - Login GitHub on Browser and close the browser tab once you get Success message.\r\n    - If you are using Settings Sync first time GIST will be created automatically when you upload your settings.\r\n    - If you already have GitHub Gist, new window will be opened to allow you to select the GitHub Gist or Skip to create new Gist.\r\n```\r\n\r\n  \\\r\n特に気になる記述や疑問がなかったので、拡張機能: `Settings Sync`をインストール。完了すると`Welcome to Settings Sync`のタブが表示されたので、`LOGIN WITH GITHUB`を選択。\r\n\r\n<img src=\"assets/images/vscode-settings-sync/vscode-settings-sync-1.png\" alt=\"Welcome to Settings Sync\" title=\"Welcome to Settings Sync\">\r\n\r\n`Authorize Settings Sync`のページがブラウザで表示されたので、`Authorize shanalikhan`する。\r\n<img src=\"assets/images/vscode-settings-sync/vscode-settings-sync-2.png\" alt=\"Github OAuth Authorization\" title=\"Github OAuth Authorization\">\r\n\r\n設定完了の表示に切り替わり、準備が完了しました。\r\n\r\n`Shift + Alt + U` もしくは、コマンドパレットから`Sync: アップデート・アップロードの設定`を選択すると、環境設定情報がGistにアップロードされました。\r\n\r\nアップロード後、変更なしにもう一度アップロードしようとしたところ、確認ダイアログが表示されました。親切ですね。\r\n<img src=\"assets/images/vscode-settings-sync/vscode-settings-sync-3.png\" alt=\"Dialog\" title=\"Dialog\">\r\n\r\n## 自動作成されたgist\r\n\r\nSettings Syncは`couldSettings`という名前のシークレットgistを自動的に作成していました。手動設定を行えば、自分で作成したgistに環境設定情報をアップロードさせることもできるようです。\r\n\r\ngistには、以下の5つのファイルが登録されていました。\r\n\r\n- cloudSettings\r\n- extensions.json\r\n- keybindings.json\r\n- keybindingsMac.json\r\n- settings.json\r\n\r\n<div class=\"gist\">\r\n    <script src=\"https://gist.github.com/takumura/bbff68078afb2d0846773965d1678c7c.js\"></script>\r\n</div>\r\n"}},{"docRef":"/nodejs/update-node-modules","content":{"title":"node_modulesを更新する","date":"2020-02-09","category":"Nodejs","tag":["npm","dependabot"],"body":"\r\n\r\nGithubで管理している Node.jsアプリケーションで、依存packageのバージョンにセキュリティリスクがある場合に、Dependabotが警告してくれました。この警告を解消する手順を確認します。\r\n\r\n## 警告の内容を確認\r\n\r\ntech-logのリポジトリで、2020-02-09 時点で9件のSecurity Alertsがレポートされていました。\r\n\r\n<img src=\"assets/images/update-node-modules/update-node-modules-1.png\" alt=\"security alerts\" title=\"security alerts\">\r\n\r\nいずれもpackage.lock.jsonに対しての変更が提案されており、間接的に依存している参照の更新が必要です。\r\n\r\n## npm auditを確認\r\n\r\nnpmにも監査のコマンドがあったことを思い出し、状況を確認してみました。\r\n\r\n```ps\r\n> npm audit\r\n...\r\nfound 625 vulnerabilities (2 low, 7 moderate, 615 high, 1 critical) in 42979 scanned packages\r\n  run `npm audit fix` to fix 624 of them.\r\n  1 vulnerability requires semver-major dependency updates.\r\n```\r\n\r\n625件。。。今後の課題にしようと思います。\r\n\r\n## 個々のPRをnpm ciして確認\r\n\r\n`npm ci`コマンドにより、pacakge.lock.json を元にnode_modulesを再構築してくれるようでした。なので「個々のPRに対してローカルリポジトリ上で`npm ci`し、appの挙動に問題がなければmasterへmergeする」という方法を試しました。\r\n\r\n```ps\r\n> npm ci\r\nnpm WARN prepare removing existing node_modules/ before installation\r\n...\r\nadded 1199 packages in 135.974s\r\n```\r\n\r\n作業開始時にnode_modulesは削除されると公式サイトに書いてありましたが、実行時にも警告が表示されました。\r\n\r\nvulnerabilitiesも着実に減少しました。\r\n\r\n```ps\r\ntar 適用時 = found 623 vulnerabilities (2 low, 7 moderate, 613 high, 1 critical) in 42979 scanned packages\r\nfstream 適用時 = found 622 vulnerabilities (2 low, 7 moderate, 612 high, 1 critical) in 42979 scanned packages\r\njs-yaml 適用時 = found 617 vulnerabilities (2 low, 4 moderate, 610 high, 1 critical) in 42979 scanned packages\r\nhandlebars 適用時 = found 616 vulnerabilities (2 low, 6 moderate, 608 high) in 42978 scanned packages\r\nlodash 適用時 = found 588 vulnerabilities (2 low, 7 moderate, 578 high, 1 critical) in 42979 scanned packages\r\nlodash.mergewith 適用時 = found 574 vulnerabilities (2 low, 3 moderate, 569 high) in 42978 scanned packages\r\nmixin-deep 適用時 = found 387 vulnerabilities (2 low, 3 moderate, 382 high) in 42978 scanned packages\r\n```\r\n\r\nまだまだ多くの更新が残っていますが、以前気軽に`npm update`したら意図せずangularのバージョンが上がって酷い目にあったので、残りはAngularのアップグレード後に確認しようと思います。。\r\n\r\n## 作業時に参照した情報\r\n\r\n- [Configuring automated security updates](https://help.github.com/ja/github/managing-security-vulnerabilities/configuring-automated-security-updates)\r\n- [npm-ci](https://docs.npmjs.com/cli/ci.html)\r\n"}},{"docRef":"/windows-app/howto-create-windows-app","content":{"title":"Windowsデスクトップ向けポータブルアプリケーション開発の現状確認","date":"2020-02-23","category":"windows app","tag":["uwp","msix","electron"],"body":"\r\n\r\n作業時間や手順を管理するためのWindows10向けデスクトップアプリケーションを作りたくなりました。2020/2月時点で、どんな開発方法があるのか確認しました。\r\n\r\n## 検索してヒットした情報\r\n\r\nまず最初にかずきさんのde:code 2019プレゼンテーションを確認。\r\n\r\n- [Windows 10 対応のデスクトップアプリを 作る技術（事前公開版）](https://www.slideshare.net/okazuki0130/windows-10-147881407)\r\n\r\n続いてMicrosoft Docs\r\n\r\n- [Windows PC 用のデスクトップ アプリの構築](https://docs.microsoft.com/ja-jp/windows/apps/desktop/)\r\n\r\nMSIXについて\r\n\r\n- [MSIX ドキュメント](https://docs.microsoft.com/ja-jp/windows/msix/)\r\n\r\nMSIXは管理者権限不要でインストール可能とあるが、インストール作業自体は必要。インストール不要なexe形式のアプリを作ろうと思った場合は、dotnet core + wpfで[自己完結型](https://docs.microsoft.com/ja-jp/dotnet/core/deploying/index#publish-self-contained)にするのが良さそうです。\r\n\r\n## Electronについて\r\n\r\n[公式サイト](https://www.electronjs.org/)のキャッチコピーは`Build cross-platform desktop apps with JavaScript, HTML, and CSS`。VSCodeがElectronを利用していることを考えると、十分に機能的なappを作成できるように思えます。\r\n\r\n## 何から手を付けるか\r\n\r\nElectronに将来性を感じる。そしてMSのテクノロジーが不確定で、この先まだまだ変更があるように感じる。なのでまずはElectron + Vue.jsの勉強から始めるのが良いのでは？と思いました。\r\n\r\n## 関連項目\r\n\r\n- [.NET Core 3.0のPublish Single File概要](https://qiita.com/Nuits/items/3136c999721e5e3fae90)\r\n"}},{"docRef":"/todo","content":{"title":"Todo リスト","date":"2019-08-12","category":"todo","body":"\r\n\r\n## 記事ストック\r\n\r\n- [x] [angular-cli-ghpages](https://github.com/angular-schule/angular-cli-ghpages)のセットアップ\r\n- [ ] 開発マシンの構成を標準化\r\n- [ ] Azure DevOps の ssh 接続確認\r\n- [ ] SourceTree の設定その後\r\n- [ ] コード規約について\r\n  - [ ] C#\r\n  - [ ] Typescript\r\n  - [ ] Angular\r\n- [ ] Visual Studio Code の設定\r\n- [ ] Visual Studio の設定\r\n- [ ] Angular Markdown Notebook のエントリーページ\r\n- [ ] VSCode の git アクセス設定\r\n\r\n## サイトの更新\r\n\r\n- [x] Doc List 画面: loading bar 表示の bug 修正\r\n- [x] gist のコードを埋め込みできない問題\r\n- [ ] PWA 化\r\n- [ ] Angular Univarsal トライアル\r\n"}}]
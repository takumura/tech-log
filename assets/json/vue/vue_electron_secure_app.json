{"title":"NuxtJS + Electronアプリで、セキュアなプロセス間通信を構成する","date":"2021-05-10","category":"Vue","tag":["vue","nuxtjs","electron","electron-store"],"body":"\r\n\r\nelectronアプリでは脆弱性対応のため、ローカルファイルシステムやOSの処理をNuxtJS側（レンダラープロセス）では行わず、メインプロセス側で実行することが推奨されています。\r\n\r\nメインプロセスとレンダラープロセス間の通信方法はelectronのバージョンアップと共に頻繁に変更されているようなので、現時点(electron v11)での安全な方法について調べ、実装していきます。\r\n\r\n## 環境確認\r\n\r\n- エディタ: VSCode\r\n- nodejs: v12.16.0\r\n- yarn: 1.22.4\r\n- electron: 11.1.1\r\n\r\n## 情報収集\r\n\r\n色々なやり方があるようで、書きつつ試しつつかなり試行錯誤しました。\r\n\r\nまず初めにこの記事を読みました。\r\n\r\n- [Electron（v.12.0.0 現在）の IPC 通信入門 - よりセキュアな方法への変遷](https://qiita.com/hibara/items/c59fb6924610fc22a9db)\r\n- [Electronのセキュリティについて大きく誤認していたこと](https://qiita.com/sprout2000/items/2b65f7d02e825549804b)\r\n\r\nどうやら「renderer側でnodejsのコードを走らせない」「main側ではpreload.tsの中でrenderer側から呼び出せる処理をexposeする」のが大事なようです。\r\n\r\n当初は[vuex-electron-persisted-state](https://github.com/chenjietao/vuex-electron-persisted-state)を使えばいいのかなと思ったのですが、mainとrendererの処理が分離できない感じだったので、このモジュールの中で使用している[electron-store](https://github.com/sindresorhus/electron-store)を使って自分で実装することにしました。\r\n\r\n## electron-storeを使った実装トライアル\r\n\r\nまずはインストールします。\r\n\r\n```ps\r\n> yarn add electron-store\r\n```\r\n\r\nそしてmain.tsから更新していきます。\r\n\r\n``` diff\r\n// main.ts\r\nimport nuxtConfig from '../renderer/nuxt.config'\r\nconst http = require('http')\r\nconst path = require('path')\r\nconst { Nuxt, Builder } = require('nuxt')\r\n- const electron = require('electron')\r\n+ const { app, BrowserWindow, ipcMain } = require('electron')\r\n\r\n// @ts-ignore\r\nnuxtConfig.rootDir = path.resolve('src/renderer')\r\n// @ts-ignore\r\nconst isDev = nuxtConfig.dev\r\nlet _NUXT_URL_ = ''\r\n\r\nconst nuxt = new Nuxt(nuxtConfig)\r\n+ const storeFilePathString = path.join(app.getPath('documents'), './electron-app')\r\n+\r\nif (isDev) {\r\n  nuxt.ready().then((n: { render: any }) => {\r\n    const builder = new Builder(n)\r\n    const server = http.createServer(n.render)\r\n    builder.build().catch((err: any) => {\r\n      console.error(err)\r\n      process.exit(1)\r\n    })\r\n    server.listen()\r\n    _NUXT_URL_ = `http://localhost:${server.address().port}`\r\n    console.log(`Nuxt working on ${_NUXT_URL_}`)\r\n-\r\n-     createElectronApp()\r\n  })\r\n} else {\r\n  _NUXT_URL_ = 'file://' + path.resolve(__dirname, '../../dist/nuxt-build/index.html')\r\n-   createElectronApp()\r\n}\r\n\r\n+ createElectronApp()\r\n+\r\nfunction createElectronApp() {\r\n+  // Keep a global reference of the window object, if you don't, the window will\r\n+  // be closed automatically when the JavaScript object is garbage collected.\r\n  let win: any = null\r\n-  const app = electron.app\r\n+\r\n  const newWin = () => {\r\n-     win = new electron.BrowserWindow({\r\n+     win = new BrowserWindow({\r\n      width: 1400,\r\n      height: 1000,\r\n      webPreferences: {\r\n-        nodeIntegration: false,\r\n-        contextIsolation: false,\r\n+        contextIsolation: true,\r\n        preload: path.resolve(path.join(__dirname, 'preload.js')),\r\n-        webSecurity: false,\r\n      },\r\n    })\r\n\r\n    win.on('closed', () => (win = null))\r\n    if (isDev) {\r\n      const { default: installExtension, VUEJS_DEVTOOLS } = require('electron-devtools-installer')\r\n      installExtension(VUEJS_DEVTOOLS.id)\r\n        .then((name: any) => {\r\n          console.log(`Added Extension:  ${name}`)\r\n          win.webContents.openDevTools()\r\n        })\r\n        .catch((err: any) => console.log('An error occurred: ', err))\r\n      const pollServer = () => {\r\n        http\r\n          .get(_NUXT_URL_, (res: any) => {\r\n            if (res.statusCode === 200) {\r\n              win.loadURL(_NUXT_URL_)\r\n            } else {\r\n              console.log('restart poolServer')\r\n              setTimeout(pollServer, 300)\r\n            }\r\n          })\r\n          .on('error', pollServer)\r\n      }\r\n      pollServer()\r\n    } else {\r\n      return win.loadURL(_NUXT_URL_)\r\n    }\r\n  }\r\n\r\n+  // setup electron-store for persisted state\r\n+  const Store = require('electron-store')\r\n+  const store = new Store({ cwd: storeFilePathString })\r\n+  ipcMain.handle('GET_STORE_VALUE', (_: any, key: any) => {\r\n+    const result = store.get(key)\r\n+    return result\r\n+  })\r\n+  ipcMain.on('SYNC_STORE', (_: any, args: any) => {\r\n+    store.set('data', args)\r\n+  })\r\n+\r\n+  // This method will be called when Electron has finished\r\n+  // initialization and is ready to create browser windows.\r\n+  // Some APIs can only be used after this event occurs.\r\n  app.on('ready', newWin)\r\n-  app.on('window-all-closed', () => app.quit())\r\n+\r\n+  app.on('window-all-closed', () => {\r\n+    // On macOS it is common for applications and their menu bar\r\n+    // to stay active until the user quits explicitly with Cmd + Q\r\n+    if (process.platform !== 'darwin') {\r\n+      app.quit()\r\n+    }\r\n+  })\r\n+\r\n  app.on('activate', () => win === null && newWin())\r\n}\r\n```\r\n\r\nポイントはこの部分。\r\n\r\n- ipcMain.handle('GET_STORE_VALUE', ...)は、renderer側から初期stateを取得する際に呼ばれ、store全体を返します。keyには`data`が入ります。\r\n- ipcMain.on('SYNC_STORE', ...)は、rendererのstoreを`store.set()`でファイルに書き出しています。argsには最新の状態のstore全体が入ります。\r\n\r\n``` ts\r\n  // setup electron-store for persisted state\r\n  const Store = require('electron-store')\r\n  const store = new Store({ cwd: storeFilePathString })\r\n  ipcMain.handle('GET_STORE_VALUE', (_: any, key: any) => {\r\n    const result = store.get(key)\r\n    return result\r\n  })\r\n  ipcMain.on('SYNC_STORE', (_: any, args: any) => {\r\n    store.set('data', args)\r\n  })\r\n```\r\n\r\nrenderer側から処理が呼び出せるようにpreload.tsに処理を追加します。\r\n\r\n``` ts\r\n// preload.ts\r\nconst { contextBridge, ipcRenderer } = require('electron')\r\n\r\n// Expose protected methods that allow the renderer process to use\r\n// the ipcRenderer without exposing the entire object\r\ncontextBridge.exposeInMainWorld('api', {\r\n  getInitialState: () => ipcRenderer.invoke('GET_STORE_VALUE', 'data'),\r\n  syncStore: (state: string) => ipcRenderer.send('SYNC_STORE', state),\r\n})\r\n```\r\n\r\nrenderer側では`fecth()`と`mounted()`のライフサイクルフックを追加して、main側とstateデータのやり取りを行います。\r\n\r\n``` diff\r\n// TodoList.vue\r\n<template>\r\n  <v-container>\r\n    <v-list>\r\n      <v-list-item v-for=\"todoData in getTodoList\" :key=\"todoData.name\">\r\n        <v-list-item-content class=\"px-2\">\r\n          <todo-data :todo=\"todoData\" />\r\n        </v-list-item-content>\r\n      </v-list-item>\r\n    </v-list>\r\n  </v-container>\r\n</template>\r\n<script lang=\"ts\">\r\nimport Vue from 'vue'\r\nimport TodoData from './TodoData.vue'\r\n+ import { accessorType } from '~/store'\r\nexport default Vue.extend({\r\n  components: {\r\n    TodoData,\r\n  },\r\n+  async fetch() {\r\n+    if (window.api) {\r\n+      const state: typeof accessorType = await window.api.getInitialState()\r\n+      if (state) {\r\n+        this.$store.replaceState(state)\r\n+      }\r\n+    }\r\n+  },\r\n+  data() {\r\n+    return {\r\n+      unsubscribe() {},\r\n+    }\r\n+  },\r\n  computed: {\r\n    getTodoList() {\r\n      return this.$accessor.todos.getTodoList\r\n    },\r\n  },\r\n+  mounted() {\r\n+    this.unsubscribe = this.$store.subscribe((mutation, state) => {\r\n+      if (mutation.type === 'todos/add' || mutation.type === 'todos/remove') {\r\n+        if (window.api) window.api.syncStore(state)\r\n+      }\r\n+    })\r\n+  },\r\n+  beforeDestroy() {\r\n+    this.unsubscribe()\r\n+  },\r\n})\r\n</script>\r\n```\r\n\r\nthis.$store.subscribeで作成したsubscriptionをunsubscribeするための記述が色々トリッキーでした。インテリセンスに頼って書いたため、正直完璧には理解できませんでした。\r\n\r\nさらに、contextBridgeでexposeした`getInitialState`と`syncStore`は`window.api`以下に注入されるのですが、このままでは型がanyのため存在しないと怒られてしまいます。\r\n\r\nエラーを抑制するために、型定義ファイルを追加しました。\r\n\r\n``` ts\r\n// types/global.d.ts\r\nimport { accessorType } from '~/store'\r\n\r\ndeclare global {\r\n  interface Window {\r\n    api: Sandbox\r\n  }\r\n}\r\n\r\nexport interface Sandbox {\r\n  getInitialState: () => Promise<typeof accessorType>\r\n  syncStore: (state: string) => void\r\n}\r\n```\r\n\r\nこれで実装は完了です。`todos/add`または`todos/remove`のmutationが行われるとconfig.jsonファイルが`[ユーザのドキュメントフォルダ]\\electron-app`以下に作成されました（削除を実装してなかったのでaddしか試していませんが。。。）\r\n\r\nそしてTodo画面を再度開いた時には、前回作成したタスクが読み込まれてタスク一覧に表示されます。\r\n\r\n## electronのdebug実行\r\n\r\nなかなか実装がうまくいかず試行錯誤する中で、electron appをdebugする方法を少し学びました。今のところmain側とrenderer側を同時にdebugすることができず、それぞれ別の方法でdebug実行しました。\r\n\r\n### renderer側のdebug\r\n\r\nrenderer側のdebugに関して特に難しいことはありません。electron appをdevelopment modeで実行し、vue.js devtoolsを使ってchromeと同じ感覚でjavascriptのdebugができます。\r\n\r\n### main側のdebug\r\n\r\n.vscode\\launch.jsonを用意することで、vscodeからdebug実行が可能です。注意点として、renderer側はbuild済みのモジュールが使われるようなので、事前に`nuxt-ts generate`しておく必要があります。そうしないとrenderer側が古い状態で尚且つrenderer側のコードがdebugできないため、状況が全く掴めずハマります。（ハマりました）\r\n\r\n``` json\r\n{\r\n  \"version\": \"0.2.0\",\r\n  \"configurations\": [\r\n    {\r\n      \"name\": \"Debug Main Process\",\r\n      \"type\": \"node\",\r\n      \"request\": \"launch\",\r\n      \"cwd\": \"${workspaceFolder}\",\r\n      \"runtimeExecutable\": \"${workspaceFolder}/node_modules/.bin/electron\",\r\n      \"windows\": {\r\n        \"runtimeExecutable\": \"${workspaceFolder}/node_modules/.bin/electron.cmd\"\r\n      },\r\n      \"args\": [\".\"],\r\n      \"outputCapture\": \"std\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n## 関連項目\r\n\r\n- [Nuxt × TypeScript × Electron × SQLiteを動かしてみた2](https://blog.mamansoft.net/2019/12/29/nuxt-typescript-electron-sqlite-project2/)\r\n- [secure-electron-store - Github](https://github.com/reZach/secure-electron-store)\r\n"}
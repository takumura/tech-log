{"title":"Angularでgistを表示する","date":"2019-11-14","category":"Angular","tag":["gist","embed","postscribe"],"body":"\r\n\r\n[Angularで動的にHTMLタグをコンポーネントに埋め込む](doc\/angular\/angular-embed-html-tag)<!--rehype:class=internal-link-->により、htmlを埋め込むことができたが、その中にscriptタグが含まれていた場合、表示させただけではscriptが実行されません。JQueryでいうところの`$()`に相当する、画面描画後にscriptを実行する処理が必要になります。\r\n\r\n本tech-log内で、gistのembedを表示するのに本課題を対応する必要があり、解決方法を調査しました。\r\n\r\n## PostScribeを利用する\r\n\r\n非同期にscriptを実行し、結果をDOMに書き込む[PostScribe](https:\/\/krux.github.io\/postscribe\/)というライブラリを利用することで、gistのembedを実現しました。\r\n\r\n**Markdownファイル(抜粋)**\r\n\r\n```html\r\ngistの表示デモ。class=\"gist\"のdivでgistのembedスクリプトを囲います\r\n<div class=\"gist\">\r\n  <script src=\"https:\/\/gist.github.com\/takumura\/bbff68078afb2d0846773965d1678c7c.js\"><\/script>\r\n<\/div>\r\n```\r\n\r\n**document.component.ts（抜粋）**\r\n\r\n```ts\r\nimport {\r\n  AfterViewInit,\r\n  ChangeDetectorRef,\r\n  Component,\r\n  ElementRef,\r\n  OnDestroy,\r\n  OnInit,\r\n  ViewChild,\r\n} from '@angular\/core';\r\nimport postscribe from 'postscribe';\r\n\r\n@Component({\r\n  selector: \"app-document\",\r\n  templateUrl: \".\/document.component.html\",\r\n  styleUrls: [\".\/document.component.scss\", \".\/vs2015.css\"],\r\n  animations: [defaultRouteAnimation],\r\n})\r\nexport class DocumentComponent implements OnInit, OnDestroy, AfterViewInit {\r\n  docInfo: DocumentInfo | null;\r\n  isOpen: boolean = true;\r\n  tocList: TocItem[] | null;\r\n\r\n  \/\/ template html中の<div #mdContent>を参照するオブジェクトを定義\r\n  @ViewChild(\"mdContent\")\r\n  mdRef: ElementRef<HTMLElement>;\r\n\r\n  private fragment: string;\r\n  private previousPath: string;\r\n  private onDestroy = new Subject();\r\n  private routeChangeSubject = new Subject();\r\n\r\n  constructor(\r\n    private markdownService: MarkdownService,\r\n    private location: Location,\r\n    private route: ActivatedRoute,\r\n    private loadingBarService: LoadingBarService,\r\n    private changeDetector: ChangeDetectorRef,\r\n  ) {}\r\n\r\n  ngOnInit() {\r\n    ...\r\n    this.route.url.pipe(takeUntil(this.onDestroy)).subscribe(params => {\r\n      const docRef = params.map(x => x.path).join(\"\/\");\r\n      if (docRef !== this.previousPath) {\r\n        this.docInfo = null;\r\n        this.isOpen = false;\r\n        this.getMarkdownDocInfo(docRef);\r\n      } else {\r\n        this.loadingBarService.hide();\r\n      }\r\n      this.previousPath = docRef;\r\n    });\r\n  }\r\n  ...\r\n  private getMarkdownDocInfo(docRef: string) {\r\n    const path = this.location.normalize('assets\/json\/' + docRef + '.json');\r\n\r\n    this.markdownService\r\n      .getDocument(path)\r\n      .pipe(takeUntil(this.onDestroy))\r\n      .subscribe(\r\n        doc => {\r\n          this.docInfo = doc;\r\n\r\n          \/\/ detect change to update virtual DOM\r\n          \/\/ and allow to access mdContentRef\r\n          this.cdRef.detectChanges();\r\n          this.mdContentRef.nativeElement.innerHTML = this.docInfo.bodyHtml;\r\n\r\n          this.showGist();\r\n          this.generateToc();\r\n          this.routeChangeSubject.next();\r\n        },\r\n        err => console.error('MarkdownService', err),\r\n      );\r\n  }\r\n\r\n  private showGist() {\r\n    const gists = this.mdContentRef.nativeElement.querySelectorAll('div.gist');\r\n    gists.forEach(gist => {\r\n      postscribe(gist, gist.innerHTML);\r\n    });\r\n  }\r\n  ...\r\n}\r\n```\r\n\r\n`this.mdContentRef.nativeElement.innerHTML = this.docInfo.bodyHtml;`でhtmlをDOMに反映させた後で、`showGist()`関数を呼んでいます。\r\n\r\n`showGist`関数では、`this.mdContentRef.nativeElement.querySelectorAll('div.gist')`で`gist`クラスを持つ`div`タグをリストアップし、発見したすべての`div`に対して`div.innerHTML`、すなわちembedのscriptを実行しています。\r\n\r\n```ts\r\npostscribe(\r\n  gist,           \/\/ div.gistのtag。このdivの中にscript実行結果が書き込まれる。\r\n  gist.innerHTML  \/\/ div.innerHTML = gistのembed script\r\n);\r\n```\r\n\r\n## 関連項目\r\n\r\n- [postscribe - Github](https:\/\/github.com\/krux\/postscribe)\r\n- [VSCode: Settings Syncで環境設定を共有する](doc\/env\/vscode-settings-sync)<!--rehype:class=internal-link-->\r\n"}
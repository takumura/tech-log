{"title":"Angularで作成したmarkdownブログサイトのbundleサイズを削減する","date":"2022-10-02","category":"Angular","tag":["angular","javascript","source-map-explorer"],"body":"\r\n\r\nAngularでmarkdownデータを表示するブログサイトのようなものを作成しました。ドラフト版が完成しリリースビルドを生成したところ約2MBのサイズになり、生成処理中にサイズが大きいと怒られてしまいます。\r\n\r\nリリースモジュールのbundle内訳を確認し、削減する方法を考えます。\r\n\r\n## リリースbundleを分析する\r\n\r\n生成したリリースbundleを分析するツールとしては`webpack-bundle-analyzer`が有名で、以前作成した旧バージョンのmarkdownブログサイトもこのツールで分析しました。ですが、Angularのbuildプロセスでは独自の最適化が施されており、`webpack-bundle-analyzer`では正しい分析ができなくなっているとのこと。\r\n\r\nAngularチームではbundleの分析に[source-map-explorer](https:\/\/github.com\/danvk\/source-map-explorer)の使用を推奨しているようなので、今回はこの`source-map-explorer`ツールを使って分析してみます。\r\n\r\n### 分析手順\r\n\r\nsource-map-explorerをdev dependencyに追加します。\r\n\r\n``` powershell\r\n> yarn add --dev source-map-explorer\r\n```\r\n\r\n次に`ng build`コマンドでリリースビルドを作成します。Angular 14では`prod`オプションはデフォルトでtrueのため指定は不要です。ですがsource mapの生成が必要だったため、`--source-map`オプションを指定しています。\r\n\r\n``` powershell\r\n>　yarn ng build --source-map\r\n```\r\n\r\n最後にpackage.jsonにsource-map-explorerコマンドを追加し、実行します。注意点として`dist\/{project name}\/main.*.js`のアスタリスクの部分はbuild毎に異なるので、実行する都度書き換えないといけません。\r\n\r\n``` json\r\n\"scripts\": {\r\n    \"ng\": \"ng\",\r\n    \"start\": \"ng serve --ssl --ssl-cert %APPDATA%\\\\ASP.NET\\\\https\\\\%npm_package_name%.pem --ssl-key %APPDATA%\\\\ASP.NET\\\\https\\\\%npm_package_name%.key\",\r\n    \"build\": \"ng build\",\r\n    \"watch\": \"ng build --watch --configuration development\",\r\n    \"test\": \"ng test\",\r\n    \"prestart\": \"node aspnetcore-https\",\r\n    \"lint\": \"ng lint\",\r\n    \"deploy\": \"ng deploy\",\r\n    \"source-map-explorer\": \"source-map-explorer .\/dist\/net6-markdown-web-engine\/main.e156c1b9a1485b3e.js\"\r\n  },\r\n```\r\n\r\n``` powershell\r\n> yarn run source-map-explorer\r\n```\r\n\r\n処理が正常に進むとブラウザが起動し、バンドル内で各モジュールが占める内訳の詳細が表示されました。\r\n\r\n<img src=\"assets\/images\/angular-blog-engine-frontend-reduce-bundle-size\/angular-blog-engine-frontend-reduce-bundle-size_1.png\" alt=\"bundle analysis\" title=\"bundle analysis\">\r\n\r\nこの中で気になったのは33.8%(576.31KB)を占めるrefactorと1.7%(28.52KB)を占めるlunr\/lunr.jsでした。\r\n\r\n## rehype-prism-plusで利用するファイルフォーマットを限定する\r\n\r\n[refactor](https:\/\/github.com\/wooorm\/refractor)モジュールは[rehype-prism-plus](https:\/\/github.com\/timlrx\/rehype-prism-plus)で利用されているcode highlightingのコアモジュールです。\r\n\r\nangular側で`import rehypePrismPlus from 'rehype-prism-plus';`のように`rehype-prism-plus`を参照するとrefactorが参照するすべての言語定義が読み込まれます。そのため非常に巨大なbundleになっていました。当然すべての言語定義は必要ないので、利用している分だけを登録するように変更します。\r\n\r\n[公式readme](https:\/\/github.com\/timlrx\/rehype-prism-plus#generating)を参考に、既存の記事で使用した9言語のみを読み込むように書き換えました。\r\n\r\n``` ts\r\nrefractor.register(csharp);\r\nrefractor.register(css);\r\nrefractor.register(diff);\r\nrefractor.register(markup);\r\nrefractor.register(javascript);\r\nrefractor.register(json);\r\nrefractor.register(powershell);\r\nrefractor.register(typescript);\r\nrefractor.register(yaml);\r\nconst myPrismPlugin = rehypePrismGenerator(refractor);\r\n\r\nconst processor = unified()\r\n  .use(remarkParse)\r\n  .use(remarkRehype, { allowDangerousHtml: true })\r\n  .use(rehypeRaw)\r\n  .use(rehypeSlug)\r\n  .use(rehypeAutolinkHeadings)\r\n  .use(rehypeExternalLinks, { target: '_blank', rel: ['noopener'] })\r\n  .use(rehypeAttrs, { properties: 'attr' })\r\n  .use(myPrismPlugin, { showLineNumbers: true })\r\n  .use(rehypeStringify);\r\nconst html = String(processor.processSync(document.content.body));\r\n```\r\n\r\n結果は576.31KB -> 27.68KBの大幅削減になりました。\r\n\r\n<img src=\"assets\/images\/angular-blog-engine-frontend-reduce-bundle-size\/angular-blog-engine-frontend-reduce-bundle-size_2.png\" alt=\"bundle analysis\" title=\"bundle analysis\">\r\n\r\n## 検索機能を簡易にする\r\n\r\n登録している記事の検索については、今回の実装時にclient側での全文検索に取り組みました。日本語にも対応した全文検索のライブラリ [Lunr.js](https:\/\/lunrjs.com\/)をangularで利用する方法について試行錯誤しながら実装を行いました。\r\n\r\nLunr.jsのtypescript対応が不十分なため、Angularコードから利用するのは単純ではありませんでした。\r\n\r\n公式のLunr languageライブラリにある[Lunr.ja.js](https:\/\/github.com\/MihaiValentin\/lunr-languages\/blob\/master\/lunr.ja.js)は、内部で使用している[tinysegmenter](https:\/\/github.com\/SamuraiT\/tinysegmenter)の依存がtypescriptのimport構文では解決できませんでした。\r\n\r\nなので、tinysegmenterの実装を直接埋め込んだカスタムのLunr.ja.jsを作成して、それをimportすることで無理やり利用させていました。\r\n\r\n``` ts\r\n\/\/ markdown-document.reducer.ts\r\n\r\n\/\/ create type JPlunr to use \"ja\" language feature\r\ntype Ilunr = (config: lunr.ConfigFunction) => lunr.Index;\r\ntype JPlunr = Ilunr & {\r\n  ja: any;\r\n};\r\n\r\n\/\/ Setup Japanese support for lunr\r\nja(lunr);\r\n\r\nexport const lunrIndex = lunr((builder) => {\r\n  builder.use((lunr as unknown as JPlunr).ja);\r\n  builder.field('title', { extractor: (doc: {}) => (doc as DocumentRef).content.title });\r\n  builder.field('category', { extractor: (doc: {}) => (doc as DocumentRef).content.category });\r\n  builder.field('body', { extractor: (doc: {}) => (doc as DocumentRef).content.body });\r\n  builder.ref('docRef');\r\n\r\n  documents.forEach((doc) => {\r\n    builder.add(doc);\r\n  });\r\n});\r\n```\r\n\r\n色々頑張って実装した割には、日本語と英語が混ざった検索などは思ったような結果が返ってきませんでした。。。ちょっとした文章管理で使う分には全文検索にこだわらず、`includes`や`indexOf`による検索でも十分なのかもしれません。\r\n\r\nということで、色々頑張ってみましたがLunr.jsの実装は全部削除して、javascriptの単純な文字列検索に切り替えます。googleでの検索では、結局`indexOf`が一番有名でパフォーマンスも安定しているようなので、これを採用することにしました。\r\n\r\nLunrを削除した結果はTotal1.13MB -> 1.07MBで、ほんの少しですが削減できました。\r\n\r\n<img src=\"assets\/images\/angular-blog-engine-frontend-reduce-bundle-size\/angular-blog-engine-frontend-reduce-bundle-size_3.png\" alt=\"bundle analysis\" title=\"bundle analysis\">\r\n\r\n## 関連項目\r\n\r\n- [Angular CLI output - how to analyze bundle files | stack overflow](https:\/\/stackoverflow.com\/questions\/46567781\/angular-cli-output-how-to-analyze-bundle-files)\r\n- [Analyzing Angular bundle with Source Map Explorer](https:\/\/dev.to\/salimchemes\/analyzing-angular-bundle-with-source-map-explorer-341)\r\n- [Supported languages - Prism](https:\/\/prismjs.com\/#languages-list)\r\n- [TypeScriptで全文検索を実行する – lunr編](https:\/\/wp-kyoto.net\/lunr-search-by-typescript\/#lunr-launguages%E3%81%8CTypeScript%E9%9D%9E%E5%AF%BE%E5%BF%9C%E3%81%AA%E3%81%AE%E3%81%A7%E5%8A%9B%E6%8A%80%E3%82%92%E4%BD%BF%E3%81%86)\r\n- [Top 6 ways to search for a string in JavaScript — And performance benchmarks](https:\/\/koukia.ca\/top-6-ways-to-search-for-a-string-in-javascript-and-performance-benchmarks-ce3e9b81ad31)\r\n"}